<?php

namespace Elastica;

use Elastica\Bulk\ResponseSet;
use Elastica\Exception\InvalidException;
use Elastica\Exception\NotFoundException;
use Elastica\Exception\ResponseException;
use Elastica\Exception\RuntimeException;
use Elastica\Query\AbstractQuery;
use Elastica\ResultSet\BuilderInterface;
use Elastica\Script\AbstractScript;
use Elastica\Type\Mapping;
use Elasticsearch\Endpoints\AbstractEndpoint;
use Elasticsearch\Endpoints\Delete;
use Elasticsearch\Endpoints\DeleteByQuery;
use Elasticsearch\Endpoints\Index as ESIndex;
use Elasticsearch\Endpoints\Indices\Mapping\Get;
use Elasticsearch\Endpoints\Indices\Type\Exists;

/**
 * Elastica type object.
 *
 * elasticsearch has for every types as a substructure. This object
 * represents a type inside a context
 * The hierarchy is as following: client -> index -> type -> document
 *
 * @author   Nicolas Ruflin <spam@ruflin.com>
 */
class Type implements SearchableInterface
{
    /**
     * Index.
     *
     * @var Index Index object
     */
    protected $_index;

    /**
     * Type name.
     *
     * @var string Type name
     */
    protected $_name;

    /**
     * @var array|string A callable that serializes an object passed to it
     */
    protected $_serializer;

    /**
     * Creates a new type object inside the given index.
     *
     * @param Index  $index Index Object
     * @param string $name  Type name
     */
    public function __construct(Index $index, string $name)
    {
        $this->_index = $index;
        $this->_name = $name;
    }

    /**
     * Adds the given document to the search index.
     *
     * @param Document $doc Document with data
     *
     * @return Response
     */
    public function addDocument(Document $doc): Response
    {
        $endpoint = new ESIndex();

        $id = $doc->getId();
        if (null !== $id && '' !== $id) {
            $endpoint->setID($id);
        }

        $options = $doc->getOptions([
            'version',
            'version_type',
            'routing',
            'percolate',
            'parent',
            'op_type',
            'consistency',
            'replication',
            'refresh',
            'timeout',
            'pipeline',
        ]);

        $endpoint->setBody($doc->getData());
        $endpoint->setParams($options);

        $response = $this->requestEndpoint($endpoint);

        $data = $response->getData();
        // set autogenerated id to document
        if ($response->isOk() &&
            ($doc->isAutoPopulate()
                || $this->getIndex()->getClient()->getConfigValue(['document', 'autoPopulate'], false))
        ) {
            if (!$doc->hasId() && isset($data['_id'])) {
                $doc->setId($data['_id']);
            }

            if (isset($data['_version'])) {
                $doc->setVersion($data['_version']);
            }
        }

        return $response;
    }

    /**
     * @param $object
     * @param Document $doc
     *
     * @throws RuntimeException
     *
     * @return Response
     */
    public function addObject($object, Document $doc = null)
    {
        if (!isset($this->_serializer)) {
            throw new RuntimeException('No serializer defined');
        }

        $data = call_user_func($this->_serializer, $object);
        if (!$doc) {
            $doc = new Document();
        }
        $doc->setData($data);

        return $this->addDocument($doc);
    }

    /**
     * Update document, using update script. Requires elasticsearch >= 0.19.0.
     *
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html
     *
     * @param Document|AbstractScript $data    Document with update data
     * @param array                   $options array of query params to use for query. For possible options check es api
     *
     * @throws InvalidException
     *
     * @return Response
     */
    public function updateDocument($data, array $options = []): Response
    {
        if (!($data instanceof Document) && !($data instanceof AbstractScript)) {
            throw new \InvalidArgumentException('Data should be a Document or Script');
        }

        if (!$data->hasId()) {
            throw new InvalidException('Document or Script id is not set');
        }

        return $this->getIndex()->getClient()->updateDocument(
            $data->getId(),
            $data,
            $this->getIndex()->getName(),
            $this->getName(),
            $options
        );
    }

    /**
     * Uses _bulk to send documents to the server.
     *
     * @param Document[] $docs    Array of Elastica\Document
     * @param array      $options Array of query params to use for query. For possible options check es api
     *
     * @return ResponseSet
     *
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html
     */
    public function updateDocuments(array $docs, array $options = []): ResponseSet
    {
        foreach ($docs as $doc) {
            $doc->setType($this->getName());
        }

        return $this->getIndex()->updateDocuments($docs, $options);
    }

    /**
     * Uses _bulk to send documents to the server.
     *
     * @param Document[] $docs    Array of Elastica\Document
     * @param array      $options Array of query params to use for query. For possible options check es api
     *
     * @return ResponseSet
     *
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html
     */
    public function addDocuments(array $docs, array $options = []): ResponseSet
    {
        foreach ($docs as $doc) {
            $doc->setType($this->getName());
        }

        return $this->getIndex()->addDocuments($docs, $options);
    }

    /**
     * Uses _bulk to send documents to the server.
     *
     * @param object[] $objects
     * @param array    $options Array of query params to use for query. For possible options check es api
     *
     * @return ResponseSet
     *
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html
     */
    public function addObjects(array $objects, array $options = []): ResponseSet
    {
        if (!isset($this->_serializer)) {
            throw new RuntimeException('No serializer defined');
        }

        $docs = [];
        foreach ($objects as $object) {
            $data = call_user_func($this->_serializer, $object);
            $doc = new Document();
            $doc->setData($data);
            $doc->setType($this->getName());
            $docs[] = $doc;
        }

        return $this->getIndex()->addDocuments($docs, $options);
    }

    /**
     * Get the document from search index.
     *
     * @param string|int $id      Document id
     * @param array      $options options for the get request
     *
     * @throws NotFoundException
     * @throws ResponseException
     *
     * @return Document
     */
    public function getDocument($id, array $options = []): Document
    {
        $endpoint = new Get();
        $endpoint->setID($id);
        $endpoint->setParams($options);

        $response = $this->requestEndpoint($endpoint);
        $result = $response->getData();

        if (!isset($result['found']) || false === $result['found']) {
            throw new NotFoundException('doc id '.$id.' not found');
        }

        if (isset($result['fields'])) {
            $data = $result['fields'];
        } elseif (isset($result['_source'])) {
            $data = $result['_source'];
        } else {
            $data = [];
        }

        $document = new Document($id, $data, $this->getName(), $this->getIndex());
        $document->setVersion($result['_version']);

        return $document;
    }

    /**
     * @param string|int   $id
     * @param array|string $data
     *
     * @return Document
     */
    public function createDocument($id = '', $data = []): Document
    {
        $document = new Document($id, $data);
        $document->setType($this);

        return $document;
    }

    /**
     * Returns the type name.
     *
     * @return string Type name
     */
    public function getName(): string
    {
        return $this->_name;
    }

    /**
     * Sets value type mapping for this type.
     *
     * @param Mapping|array $mapping Elastica\Type\MappingType object or property array with all mappings
     * @param array         $query   querystring when put mapping (for example update_all_types)
     *
     * @return Response
     */
    public function setMapping($mapping, array $query = []): Response
    {
        $mapping = Mapping::create($mapping);
        $mapping->setType($this);

        return $mapping->send($query);
    }

    /**
     * Returns current mapping for the given type.
     *
     * @return array Current mapping
     */
    public function getMapping(): array
    {
        $response = $this->requestEndpoint(new Get());
        $data = $response->getData();

        $mapping = array_shift($data);
        if (isset($mapping['mappings'])) {
            return $mapping['mappings'];
        }

        return [];
    }

    /**
     * {@inheritdoc}
     */
    public function createSearch($query = '', $options = null, BuilderInterface $builder = null): Search
    {
        $search = $this->getIndex()->createSearch($query, $options, $builder);
        $search->addType($this);

        return $search;
    }

    /**
     * {@inheritdoc}
     */
    public function search($query = '', $options = null): ResultSet
    {
        $search = $this->createSearch($query, $options);

        return $search->search();
    }

    /**
     * {@inheritdoc}
     */
    public function count($query = ''): int
    {
        $search = $this->createSearch($query);

        return $search->count();
    }

    /**
     * Returns index client.
     *
     * @return Index Index object
     */
    public function getIndex(): Index
    {
        return $this->_index;
    }

    /**
     * @param Document $document
     *
     * @return Response
     */
    public function deleteDocument(Document $document): Response
    {
        $options = $document->getOptions([
            'version',
            'version_type',
            'routing',
            'parent',
            'replication',
            'consistency',
            'refresh',
            'timeout',
        ]);

        return $this->deleteById($document->getId(), $options);
    }

    /**
     * Uses _bulk to delete documents from the server.
     *
     * @param Document[] $docs Array of Elastica\Document
     *
     * @return ResponseSet
     *
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html
     */
    public function deleteDocuments(array $docs): ResponseSet
    {
        foreach ($docs as $doc) {
            $doc->setType($this->getName());
        }

        return $this->getIndex()->deleteDocuments($docs);
    }

    /**
     * Deletes an entry by its unique identifier.
     *
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete.html
     *
     * @param int|string $id      Document id
     * @param array      $options
     *
     * @throws \InvalidArgumentException
     * @throws NotFoundException
     *
     * @return Response Response object
     */
    public function deleteById($id, array $options = []): Response
    {
        if (empty($id) || !trim($id)) {
            throw new \InvalidArgumentException();
        }

        $endpoint = new Delete();
        $endpoint->setID($id);
        $endpoint->setParams($options);

        $response = $this->requestEndpoint($endpoint);

        $responseData = $response->getData();

        if (isset($responseData['result']) && 'not_found' === $responseData['result']) {
            throw new NotFoundException('Doc id '.$id.' not found and can not be deleted');
        }

        return $response;
    }

    /**
     * Deletes the given list of ids from this type.
     *
     * @param array       $ids
     * @param string|bool $routing Optional routing key for all ids
     *
     * @return Response Response  object
     */
    public function deleteIds(array $ids, $routing = false): Response
    {
        return $this->getIndex()->getClient()->deleteIds($ids, $this->getIndex(), $this, $routing);
    }

    /**
     * Deletes entries in the db based on a query.
     *
     * @param Query|AbstractQuery|string|array $query   Query object
     * @param array                            $options Optional params
     *
     * @return Response
     *
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html
     */
    public function deleteByQuery($query, array $options = []): Response
    {
        $query = Query::create($query);

        $endpoint = new DeleteByQuery();
        $endpoint->setBody($query->toArray());
        $endpoint->setParams($options);

        return $this->requestEndpoint($endpoint);
    }

    /**
     * Makes calls to the elasticsearch server based on this type.
     *
     * @param string $path   Path to call
     * @param string $method Rest method to use (GET, POST, DELETE, PUT)
     * @param array  $data   OPTIONAL Arguments as array
     * @param array  $query  OPTIONAL Query params
     *
     * @return Response Response object
     */
    public function request(string $path, string $method, array $data = [], array $query = []): Response
    {
        $path = $this->getName().'/'.$path;

        return $this->getIndex()->request($path, $method, $data, $query);
    }

    /**
     * Makes calls to the elasticsearch server with usage official client Endpoint based on this type.
     *
     * @param AbstractEndpoint $endpoint
     *
     * @return Response
     */
    public function requestEndpoint(AbstractEndpoint $endpoint): Response
    {
        $cloned = clone $endpoint;
        $cloned->setType($this->getName());

        return $this->getIndex()->requestEndpoint($cloned);
    }

    /**
     * Sets the serializer callable used in addObject.
     *
     * @see Type::addObject
     *
     * @param array|string $serializer @see Type::_serializer
     *
     * @return $this
     */
    public function setSerializer($serializer): self
    {
        $this->_serializer = $serializer;

        return $this;
    }

    /**
     * Checks if the given type exists in Index.
     *
     * @return bool True if type exists
     */
    public function exists(): bool
    {
        $response = $this->requestEndpoint(new Exists());

        return 200 === $response->getStatus();
    }
}
